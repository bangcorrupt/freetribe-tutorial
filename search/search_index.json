{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is a tutorial for Freetribe,  a free, open-source firmware for Electribe 2. A series of code examples demonstrate features of the Freetribe API, starting with basic operations and moving toward a more complex application.</p> <p>Before continuing, review the Getting Started section of the Freetribe Documentation. You will also need to install the toolchain and  attach a debugger in order to run the code examples.</p>"},{"location":"essential-functions/","title":"Essential Functions","text":"<p>This minimal example is reproduced from the Getting Started section of the Freetribe Documentation. We demonstrate the essential functions for Freetribe applications, use a non-blocking delay, and toggle an LED.</p>"},{"location":"essential-functions/#create-application-files","title":"Create Application Files","text":"<p>Create a directory for the app and a file for the code. The app directory must be under the <code>freetribe/cpu/src/apps/</code> directory for the build system to work.</p> <pre><code>mkdir cpu/src/apps/my-blink\ntouch cpu/src/apps/my-blink/my_blink.c\n</code></pre>"},{"location":"essential-functions/#include-freetribe-api","title":"Include Freetribe API","text":"<p>First, we must include the Freetribe API:</p> <pre><code>#include \"freetribe.h\"\n</code></pre> <p>This gives us access to all the functions our application should need for interacting with the device.</p>"},{"location":"essential-functions/#override-initialisation-function","title":"Override Initialisation Function","text":"<p>The <code>app_init()</code> function is defined as a weak reference in the Freetribe API, it takes no arguments and returns <code>t_status</code>, an integer error code. We override it to do any one time initialisation required by our app. This is a good place to register callbacks for events we are interested in, and do any setup required by external libraries.</p> <p>In this example, we initialise a static global variable of type <code>t_delay_state</code> to hold the parameters of our delay. The <code>ft_start_delay()</code> function sets the delay time in microseconds and resets the delay state to zero.</p> <pre><code>// 0.5 seconds in microseconds.\n#define DELAY_TIME 500000\n\nstatic t_delay_state g_blink_delay;\n\nt_status app_init(void) {\n\n    // Initialise delay.\n    ft_start_delay(&amp;g_blink_delay, DELAY_TIME);\n\n    return SUCCESS;\n}\n</code></pre>"},{"location":"essential-functions/#override-run-function","title":"Override Run Function","text":"<p>The <code>app_run()</code> function is called continuously by the kernel in the main loop, after <code>app_init()</code> has completed. It takes no arguments and returns nothing.</p> <p>In this example, we toggle an LED on the panel if one second has passed, and reset the delay start time. The <code>ft_delay()</code> function returns <code>true</code> if the delay time has expired since <code>ft_start_delay()</code> was executed. The <code>ft_toggle_led()</code> function takes the index of an led, and toggles it on or off. We can call <code>ft_start_delay()</code> again with the same struct to reset the delay to zero.</p> <pre><code>void app_run(void) {\n\n    // Wait for delay.\n    if (ft_delay(&amp;g_blink_delay)) {\n\n        // Toggle LED.\n        ft_toggle_led(LED_TAP);\n\n        // Reset start time.\n        ft_start_delay(&amp;g_blink_delay, DELAY_TIME);\n    }\n}\n</code></pre>"},{"location":"essential-functions/#build-the-application","title":"Build the Application","text":"<p>We build the application by running <code>make</code> in the root <code>freetribe</code> directory. We pass the name of our application directory (not the path) in the <code>APP</code> environment variable.</p> <pre><code>make clean &amp;&amp; make APP=my-blink\n</code></pre>"},{"location":"essential-functions/#run-the-application","title":"Run the Application","text":"<p>First we must attach a debugger and start a GDB server. Then we can connect to the GDB server and run the application:</p> <pre><code>cd cpu &amp;&amp; arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>freetribe/cpu/.gdbinit</code> should load the application and set a breakpoint at <code>main</code>. Once we hit the breakpoint, input <code>c</code> and press <code>Enter</code> to continue. The LED on the <code>[Tap]</code> button should blink at a rate of 1 Hz.</p>"},{"location":"essential-functions/#things-to-try","title":"Things to Try","text":"<p>Try modifying the LED blink rate by passing different values to <code>ft_start_delay()</code>.</p> <p>Try toggling a different LED by passing different values to <code>ft_toggle_led()</code>.</p> <p>Try toggling multiple LEDs at different rates, perhaps using separate <code>t_delay_state</code> variables for each LED.</p>"},{"location":"essential-functions/#next-steps","title":"Next Steps","text":"<p>In the next example, we will register a callback for user tick events, providing a regular sense of time to our application.</p>"},{"location":"essential-functions/#blinkc","title":"<code>blink.c</code>","text":"<pre><code>// Freetribe: Minimal Example\n// License: AGPL-3.0-or-later\n\n#include \"freetribe.h\"\n\n// 0.5 seconds in microseconds.\n#define DELAY_TIME 500000\n\nstatic t_delay_state g_blink_delay;\n\nt_status app_init(void) {\n\n    // Initialise delay.\n    ft_start_delay(&amp;g_blink_delay, DELAY_TIME);\n\n    return SUCCESS;\n}\n\nvoid app_run(void) {\n\n    // Wait for delay.\n    if (ft_delay(&amp;g_blink_delay)) {\n\n        // Toggle LED.\n        ft_toggle_led(LED_TAP);\n\n        // Reset start time.\n        ft_start_delay(&amp;g_blink_delay, DELAY_TIME);\n    }\n}\n</code></pre>"},{"location":"license/","title":"License","text":"<p>AGPL-3.0-or-later.</p>"},{"location":"registering-callbacks/","title":"Registering Callbacks","text":"<p>In the previous example, we used a non-blocking delay to blink an LED at regular intervals. In this example, we will achieve the same result by registering a callback for tick events.</p>"},{"location":"registering-callbacks/#create-application-files","title":"Create Application Files","text":"<p>Template source files are provided to speed up development. Create a new directory for our app and copy <code>template_app.c</code> to a file with our app name:</p> <pre><code>mkdir cpu/src/apps/my-blink-tick\ncp template_app.c cpu/src/apps/my-blink-tick/my_blink_tick.c\n</code></pre>"},{"location":"registering-callbacks/#initialise-application","title":"Initialise Application","text":"<p>In the <code>app_init()</code> function we register a callback for user tick events. The function <code>ft_register_tick_callback()</code> takes 2 arguments: an integer describing the ratio of user ticks to kernel ticks, and the function to call when user tick events occur. In this example, we set the 'divisor' to 0, indicating one user tick for every kernel tick. This will trigger our callback every millisecond. We pass the name of a function, <code>_tick_callback</code>, as the second argument. We will define this function in a later step.</p> <pre><code>#define USER_TICK_DIV 0   // User tick for every systick (~1ms).\n#define LED_TICK_DIV 500 // LED tick per 500 user ticks (~0.5s).\n\nt_status app_init(void) {\n\n    t_status status = ERROR;\n\n    ft_register_tick_callback(USER_TICK_DIV, _tick_callback);\n\n    status = SUCCESS;\n    return status;\n}\n</code></pre>"},{"location":"registering-callbacks/#define-run-behaviour","title":"Define Run Behaviour","text":"<p>Our <code>app_run()</code> function is similar to the previous example, only we do not need to call delay functions. If a flag has been set, we toggle an LED and clear the flag. We will set the flag in our callback function below.</p> <pre><code>void app_run(void) {\n\n    if (g_toggle_led) {\n        ft_toggle_led(LED_TAP);\n\n        g_toggle_led = false;\n    }\n}\n</code></pre>"},{"location":"registering-callbacks/#define-tick-callback","title":"Define Tick Callback","text":"<p>In our tick callback, we count the number of ticks and set a flag each time we reach 500. We test and clear this flag in the <code>app_run()</code> function, toggling the LED twice per second. The tick callback takes no arguments and returns nothing. It is important that the function prototype matches this form, as defined in the Freetribe API.</p> <pre><code>static void _tick_callback(void) {\n\n    static uint16_t led_count;\n\n    if (led_count++ &gt;= LED_TICK_DIV) {\n\n        g_toggle_led = true;\n        led_count = 0;\n    }\n}\n</code></pre>"},{"location":"registering-callbacks/#build-and-run-the-application","title":"Build and Run the Application","text":"<p>Build the application by passing <code>my-blink-tick</code> to <code>make</code> in the <code>APP</code> environment variable:</p> <pre><code>make clean &amp;&amp; make APP=my-blink-tick\n</code></pre> <p>Then run the application using GDB:</p> <pre><code>cd cpu &amp;&amp; arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>cpu/.gdbinit</code> should take care of attaching to the debugger's GDB server and loading the ELF.</p> <p>If all is well, you should see the <code>[Tap]</code> LED toggle once per second.</p>"},{"location":"registering-callbacks/#things-to-try","title":"Things to Try","text":"<p>Repeat the tasks from the previous example, toggling different LEDs at different rates.</p>"},{"location":"registering-callbacks/#next-steps","title":"Next Steps","text":"<p>In the next example, we will register callbacks for user input and use them to provide feedback.</p>"},{"location":"registering-callbacks/#blink-tickc","title":"<code>blink-tick.c</code>","text":"<pre><code>// Freetribe: blink-tick\n// License: AGPL-3.0-or-later\n\n/*----- Includes -----------------------------------------------------*/\n\n#include \"freetribe.h\"\n\n/*----- Macros and Definitions ---------------------------------------*/\n\n#define USER_TICK_DIV 0   // User tick for every systick (~1ms).\n#define LED_TICK_DIV 500 // LED tick per 500 user ticks (~0.5s).\n\n/*----- Static variable definitions ----------------------------------*/\n\nstatic bool g_toggle_led = false;\n\n/*----- Static function prototypes -----------------------------------*/\n\nstatic void _tick_callback(void);\n\n/*----- Extern function implementations ------------------------------*/\n\n/**\n * @brief   Initialise application.\n */\nt_status app_init(void) {\n\n    t_status status = ERROR;\n\n    ft_register_tick_callback(USER_TICK_DIV, _tick_callback);\n\n    status = SUCCESS;\n    return status\n}\n\n/**\n * @brief   Run application.\n */\nvoid app_run(void) {\n\n    if (g_toggle_led) {\n        ft_toggle_led(LED_TAP);\n\n        g_toggle_led = false;\n    }\n}\n\n/*----- Static function implementations ------------------------------*/\n\n/**\n * @brief   Callback triggered by user tick events.\n */\nstatic void _tick_callback(void) {\n\n    static uint16_t led_count;\n\n    if (led_count++ &gt;= LED_TICK_DIV) {\n\n        g_toggle_led = true;\n        led_count = 0;\n    }\n}\n\n/*----- End of file --------------------------------------------------*/\n</code></pre>"},{"location":"support/","title":"Support","text":""},{"location":"support/#support-for-you","title":"Support for You","text":"<p>If you need help with this project, please visit the  Freetribe discussion forum  on Github.</p>"},{"location":"support/#support-for-me","title":"Support for Me","text":"<p>Freetribe is free (as in GPL) and always will be. If you would like to support my work you are most welcome to  become a sponsor. Freetribe exists because people sponsored Hacktribe. Your support helps keep me motivated, fuelled and focussed.</p>"},{"location":"user-input/","title":"User Input","text":"<p>In the previous example we registered a callback for tick events. In this example, we will register callbacks for knob and button input, then use them to send MIDI CC messages and toggle an LED.</p>"},{"location":"user-input/#create-application-files","title":"Create Application Files","text":"<pre><code>mkdir cpu/src/apps/my-midi-knob\ncp template_app.c cpu/src/apps/my-midi-knob/my_midi_knob.c\n</code></pre>"},{"location":"user-input/#initialise-application","title":"Initialise Application","text":"<p>In the <code>app_init()</code> function, we register callbacks for knob and button input events.</p> <pre><code>t_status app_init(void) {\n\n    t_status status = ERROR;\n\n    ft_register_panel_callback(KNOB_EVENT, _knob_callback);\n    ft_register_panel_callback(BUTTON_EVENT, _button_callback);\n\n    status =  SUCCESS;\n    return status\n}\n</code></pre>"},{"location":"user-input/#define-run-behaviour","title":"Define Run Behaviour","text":"<p>Our <code>app_run()</code> function is very similar to the previous example. If a flag is set, we toggle an LED and clear the flag. The flag will be set in our button callback below. In this example, we toggle the <code>[Play]</code> button LED.</p> <pre><code>void app_run(void) {\n\n    if (g_toggle_led) {\n        ft_toggle_led(LED_PLAY);\n\n        g_toggle_led = false;\n    }\n}\n</code></pre>"},{"location":"user-input/#define-knob-callback","title":"Define Knob Callback","text":"<p>The knob callback takes 2 arguments and returns nothing. The first argument is the index of the knob and the second is it's value. In this example, we send a MIDI CC message on channel 1, with CC number equal to knob index and CC value equal to half knob value. The panel MCU sends 8 bit unsigned values in the range 0...255 for knobs, so we right shift by 1 for MIDI CC values.</p> <pre><code>void _knob_callback(uint8_t index, uint8_t value) {\n\n    ft_send_cc(0, index, value &gt;&gt; 1);\n}\n</code></pre>"},{"location":"user-input/#define-button-callback","title":"Define Button Callback","text":"<p>The button callback prototype is similar to the knob callback. It takes 2 arguments, button index and button state, and returns nothing. In this example, we parse the button index and test the button state. When the <code>[Play]</code> button is depressed we set a flag to toggle it's LED. We ignore when the <code>[Play]</code> button is released.</p> <pre><code>void _button_callback(uint8_t index, bool state) {\n\n    switch (index) {\n\n    case BUTTON_PLAY:\n\n        if (state == 1) {\n            g_toggle_led == true;\n        }\n        break;\n\n    default:\n        break;\n    }\n}\n</code></pre>"},{"location":"user-input/#build-and-run-the-application","title":"Build and Run the Application","text":"<p>Build the application by passing <code>midi-knob</code> to <code>make</code> in the <code>APP</code> environment variable:</p> <pre><code>make clean &amp;&amp; make APP=my-midi-knob\n</code></pre> <p>Then run the application using GDB:</p> <pre><code>cd cpu &amp;&amp; arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>cpu/.gdbinit</code> should take care of attaching to the debugger's GDB server and loading the ELF.</p> <p>If all is well, moving any of the knobs should send MIDI CC messages. Pressing the <code>[Play]</code> button should toggle it's LED.</p>"},{"location":"user-input/#things-to-try","title":"Things to Try","text":"<p>Try remapping the CC number to something other than the knob index.</p> <p>Try sending CC messages for button events.</p> <p>Try sending note messages for trigger pad input.</p>"},{"location":"user-input/#next-steps","title":"Next Steps","text":"<p>In the next example, we will see how to use the display.</p>"},{"location":"user-input/#midi-knobc","title":"<code>midi-knob.c</code>","text":"<pre><code>// Freetribe: midi-knob\n// License: AGPL-3.0-or-later\n\n/*----- Includes -----------------------------------------------------*/\n\n#include \"freetribe.h\"\n\n/*----- Macros and Definitions ---------------------------------------*/\n\n#define BUTTON_PLAY 0x2\n\n/*----- Static variable definitions ----------------------------------*/\n\nstatic bool g_toggle_led = false;\n\n/*----- Extern variable definitions ----------------------------------*/\n\n/*----- Static function prototypes -----------------------------------*/\n\nvoid _knob_callback(uint8_t index, uint8_t value);\nvoid _button_callback(uint8_t index, bool state);\n\n/*----- Extern function implementations ------------------------------*/\n\n/**\n * @brief   Initialise application.\n */\nt_status app_init(void) {\n\n    t_status status = ERROR;\n\n    ft_register_panel_callback(KNOB_EVENT, _knob_callback);\n    ft_register_panel_callback(BUTTON_EVENT, _button_callback);\n\n    status = SUCCESS;\n    return status;\n}\n\n/**\n * @brief   Run application.\n */\nvoid app_run(void) {\n\n    if (g_toggle_led) {\n        ft_toggle_led(LED_PLAY);\n\n        g_toggle_led = false;\n    }\n}\n\n/*----- Static function implementations ------------------------------*/\n\n/**\n * @brief   Callback triggered by panel knob events.\n */\nvoid _knob_callback(uint8_t index, uint8_t value) {\n\n    ft_send_cc(0, index, value &gt;&gt; 1);\n}\n\n/**\n * @brief   Callback triggered by panel button events.\n */\nvoid _button_callback(uint8_t index, bool state) {\n\n    switch (index) {\n\n    case BUTTON_PLAY:\n        if (state == 1) {\n            g_toggle_led = true;\n        }\n        break;\n    }\n}\n\n/*----- End of file --------------------------------------------------*/\n</code></pre>"}]}