{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is a tutorial for Freetribe,  a free, open-source firmware for Electribe 2. A series of code examples demonstrate features of the Freetribe API, starting with basic operations and moving toward a more complex application.</p> <p>Before continuing, review the Getting Started section of the Freetribe Documentation. You will also need to install the toolchain and  attach a debugger in order to run the code examples.</p>"},{"location":"essential-functions/","title":"Essential Functions","text":"<p>This minimal example is reproduced from the Getting Started section of the Freetribe Documentation. We demonstrate the essential functions for Freetribe applications, use a non-blocking delay, and toggle an LED.</p>"},{"location":"essential-functions/#create-application-files","title":"Create Application Files","text":"<p>Create a directory for the app and a file for the code.  The app directory must be under the <code>freetribe/cpu/src/apps/</code> directory for the build system to work.</p> <pre><code>mkdir cpu/src/apps/blink\ntouch cpu/src/apps/blink.c\n</code></pre>"},{"location":"essential-functions/#include-freetribe-api","title":"Include Freetribe API","text":"<p>First, we must include the Freetribe API:</p> <pre><code>#include \"freetribe.h\"\n</code></pre> <p>This gives us access to all the functions our  application should need for interacting with the device.</p>"},{"location":"essential-functions/#override-initialisation-function","title":"Override Initialisation Function","text":"<p>The function <code>app_init()</code> is defined as a weak reference in the Freetribe API. We override it to do any one time initialisation required by our app.  This is a good place to register callbacks for events we are interested in,  and do any setup required by external libraries.</p> <p>In this example, we initialise a static global variable to hold the start time of our delay.  The <code>app_init()</code> function takes no arguments and returns <code>t_status</code>, an integer error code.</p> <p>We also define a macro <code>DELAY_TIME</code> as the number of microseconds in 1 second.</p> <pre><code>// 1 second in microseconds.\n#define DELAY_TIME 1000000 \n\nstatic uint32_t g_start_time; \n\nt_status app_init(void) {\n\n    // Set start time.\n    g_start_time = ft_get_delay_current();\n\n    return SUCCESS;\n}\n</code></pre>"},{"location":"essential-functions/#override-run-function","title":"Override Run Function","text":"<p>The <code>app_run()</code> function is also defined as a  weak reference in the Freetribe API.  We override it to do any continuous processing required by our app. In this example, we toggle an LED on the panel if 1 second has passed,  and reset the delay start time. </p> <p>The <code>app_run</code> function takes no arguments and returns nothing.</p> <pre><code>void app_run(void) {\n\n    // Wait for delay.\n    if (ft_delay(g_start_time, DELAY_TIME)) {\n\n        // Toggle LED.\n        ft_toggle_led(LED_TAP);\n\n        // Reset start time.\n        g_start_time = ft_get_delay_current();\n\n    }\n}\n</code></pre> <p>Each time the <code>app_run()</code> function is executed, we test the return value of <code>ft_delay()</code>. The function <code>ft_delay()</code> returns <code>true</code> if <code>delay_time</code> microseconds have passed since <code>start_time</code>. Once we enter the <code>if(...)</code> block, we toggle an LED and reset the start time  to the current value of the delay timer.</p>"},{"location":"essential-functions/#build-the-application","title":"Build the Application","text":"<p>We build the application by running <code>make</code> in the root <code>freetribe</code> directory. We pass the name of our application directory (not the path) in the <code>APP</code> environment variable.</p> <pre><code>make clean &amp;&amp; make APP=blink\n</code></pre>"},{"location":"essential-functions/#run-the-application","title":"Run the Application","text":"<p>First we must attach a debugger and start a GDB server.  Then we can connect to the GDB server and run the application:</p> <pre><code>arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>freetribe/cpu/.gdbinit</code> should load the application and set a breakpoint at <code>main</code>. Once we hit the breakpoint, input <code>c</code> and press <code>Enter</code> to continue.  The LED on the <code>[Tap]</code> button should blink at a rate of 1 Hz.</p>"},{"location":"essential-functions/#next-steps","title":"Next Steps","text":"<p>In the next example, we will register a callback for user tick events,  providing a synchronised sense of time to our application.</p>"},{"location":"essential-functions/#blinkc","title":"<code>blink.c</code>","text":"<pre><code>// Freetribe: Minimal Example\n// License: AGPL-3.0-or-later\n\n#include \"freetribe.h\"\n\n// 1 second in microseconds.\n#define DELAY_TIME 1000000 \n\nstatic uint32_t g_start_time; \n\nt_status app_init(void) {\n\n    // Set start time.\n    g_start_time = ft_get_delay_current();\n\n    return SUCCESS;\n}\n\nvoid app_run(void) {\n\n    // Wait for delay.\n    if (ft_delay(g_start_time, DELAY_TIME)) {\n\n        // Toggle LED.\n        ft_toggle_led(LED_TAP);\n\n        // Reset start time.\n        g_start_time = ft_get_delay_current();\n\n    }\n}\n</code></pre>"},{"location":"license/","title":"License","text":"<p>AGPL-3.0-or-later.</p>"},{"location":"registering-callbacks/","title":"Registering Callbacks","text":"<p>In the previous example, we used  a non-blocking delay to blink an LED at regular intervals. In this example, we will achieve the same result by registering a callback for tick events.  </p>"},{"location":"registering-callbacks/#create-application-files","title":"Create Application Files","text":"<p>Template source files are provided to speed up development. Create a new directory for our app and copy <code>template_app.c</code> to a file with our app name:</p> <pre><code>mkdir cpu/src/apps/blink-tick\ncp template_app.c cpu/src/apps/blink-tick/blink-tick.c\n</code></pre>"},{"location":"registering-callbacks/#initialise-application","title":"Initialise Application","text":"<p>In the <code>app_init()</code> function we register a callback for user tick events. The function <code>ft_register_tick_callback()</code> takes 2 arguments: an integer describing the ratio of user ticks to kernel ticks, and the function to call when user tick events occur.  In this example, we set the 'divisor' to 0, indicating one user tick for every kernel tick.  This will trigger our callback every millisecond.  We pass the name of a function, <code>_tick_callback</code>, as the second argument.  We will define this function in a later step.</p> <pre><code>t_status app_init(void) {\n\n    t_status status = ERROR;\n\n    ft_register_tick_callback(0, _tick_callback);\n\n    return SUCCESS;\n}\n</code></pre>"},{"location":"registering-callbacks/#define-run-behaviour","title":"Define Run Behaviour","text":"<p>Our <code>app_run()</code> function is similar to the previous example, only we do not need to call delay functions. If a flag has been set,  we toggle an LED and clear the flag.  We will set the flag in our callback function below.</p> <pre><code>void app_run(void) {\n\n    if (g_toggle_led) {\n        ft_toggle_led(LED_TAP);\n\n        g_toggle_led = false;\n    }\n}\n</code></pre>"},{"location":"registering-callbacks/#define-tick-callback","title":"Define Tick Callback","text":"<p>In our tick callback, we count the number of ticks and set a flag each time we reach 1000. We test and clear this flag in the <code>app_run()</code> function, toggling the LED once per second.  The tick callback takes no arguments and returns nothing.  It is important that the function prototype matches this form, as defined in the Freetribe API.</p> <pre><code>static void _tick_callback(void) {\n\n    static uint16_t led_count;\n\n    if (led_count &gt;= 1000) {\n\n        g_toggle_led = true;\n        led_count = 0;\n\n    } else {\n        led_count++;\n    }\n}\n</code></pre>"},{"location":"registering-callbacks/#build-and-run-the-application","title":"Build and Run the Application","text":"<p>Build the application by passing <code>blink-tick</code> to <code>make</code>  in the <code>APP</code> environment variable:</p> <pre><code>make clean &amp;&amp; make APP=blink-tick\n</code></pre> <p>Then run the application using GDB:</p> <pre><code>cd cpu &amp;&amp; arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>cpu/.gdbinit</code> should take care of attaching to the debugger's GDB server and loading the ELF.</p> <p>If all is well, you should see the <code>[Tap]</code> LED toggle once per second.</p>"},{"location":"registering-callbacks/#blink-tickc","title":"<code>blink-tick.c</code>","text":"<pre><code>// Freetribe: blink-tick \n// License: AGPL-3.0-or-later\n\n/*----- Includes -----------------------------------------------------*/\n\n#include \"freetribe.h\"\n\n/*----- Macros and Definitions ---------------------------------------*/\n\n#define USER_TICK_DIV 0   // User tick for every systick (~1ms).\n#define LED_TICK_DIV 1000 // LED tick per 1000 user ticks (~1s).\n\n/*----- Static variable definitions ----------------------------------*/\n\nstatic bool g_toggle_led = false;\n\n/*----- Static function prototypes -----------------------------------*/\n\nstatic void _tick_callback(void);\n\n/*----- Extern function implementations ------------------------------*/\n\n/**\n * @brief   Initialise application.\n */\nt_status app_init(void) {\n\n    t_status status = ERROR;\n\n    ft_register_tick_callback(USER_TICK_DIV, _tick_callback);\n\n    return SUCCESS;\n}\n\n/**\n * @brief   Run application.\n */\nvoid app_run(void) {\n\n    if (g_toggle_led) {\n        ft_toggle_led(LED_TAP);\n\n        g_toggle_led = false;\n    }\n}\n\n/*----- Static function implementations ------------------------------*/\n\n/**\n * @brief   Callback triggered by user tick events.\n */\nstatic void _tick_callback(void) {\n\n    static uint16_t led_count;\n\n    if (led_count &gt;= LED_TICK_DIV) {\n\n        g_toggle_led = true;\n        led_count = 0;\n\n    } else {\n        led_count++;\n    }\n}\n\n/*----- End of file --------------------------------------------------*/\n</code></pre>"},{"location":"support/","title":"Support","text":""},{"location":"support/#support-for-you","title":"Support for You","text":"<p>If you need help with this project, please visit the  Freetribe discussion forum  on Github.</p>"},{"location":"support/#support-for-me","title":"Support for Me","text":"<p>Freetribe is free (as in GPL) and always will be. If you would like to support my work you are most welcome to  become a sponsor. Freetribe exists because people sponsored Hacktribe. Your support helps keep me motivated, fuelled and focussed.</p>"},{"location":"template_example/","title":"Example Template","text":""},{"location":"template_example/#create-application-files","title":"Create Application Files","text":"<pre><code>mkdir cpu/src/apps/example\ncp template_app.c cpu/src/apps/blink-tick/blink-tick.c\n</code></pre>"},{"location":"template_example/#initialise-application","title":"Initialise Application","text":"<p>In the <code>app_init()</code> function </p> <pre><code>t_status app_init(void) {\n\n    t_status status = ERROR;\n\n    return SUCCESS;\n}\n</code></pre>"},{"location":"template_example/#define-run-behaviour","title":"Define Run Behaviour","text":"<p>Our <code>app_run()</code> function </p> <pre><code>void app_run(void) {\n\n}\n</code></pre>"},{"location":"template_example/#define-callback","title":"Define Callback","text":"<p>In our callback, </p> <pre><code>static void _callback(void) {\n\n}\n</code></pre>"},{"location":"template_example/#build-and-run-the-application","title":"Build and Run the Application","text":"<p>Build the application by passing <code>example</code> to <code>make</code>  in the <code>APP</code> environment variable:</p> <pre><code>make clean &amp;&amp; make APP=example\n</code></pre> <p>Then run the application using GDB:</p> <pre><code>cd cpu &amp;&amp; arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>cpu/.gdbinit</code> should take care of attaching to the debugger's GDB server and loading the ELF.</p> <p>If all is well, </p>"},{"location":"template_example/#examplec","title":"<code>example.c</code>","text":"<pre><code>// Freetribe: blink-tick \n// License: AGPL-3.0-or-later\n\n/*----- Includes -----------------------------------------------------*/\n\n#include \"freetribe.h\"\n\n/*----- End of file --------------------------------------------------*/\n</code></pre>"},{"location":"user-input/","title":"User Input","text":"<p>In the previous example we regiseterd a callback for tick events. In this example, we will register callbacks for knob and button input,  then use them to send MIDI CC messages and toggle an LED. </p>"},{"location":"user-input/#create-application-files","title":"Create Application Files","text":"<pre><code>mkdir cpu/src/apps/midi-knob\ncp template_app.c cpu/src/apps/blink-tick/midi-knob.c\n</code></pre>"},{"location":"user-input/#initialise-application","title":"Initialise Application","text":"<p>In the <code>app_init()</code> function, we register callbacks for knob and button input events.</p> <pre><code>t_status app_init(void) {\n\n    t_status status = ERROR;\n\n    ft_register_panel_callback(KNOB_EVENT, _knob_callback);\n    ft_register_panel_callback(BUTTON_EVENT, _button_callback);\n\n    return SUCCESS;\n}\n</code></pre>"},{"location":"user-input/#define-run-behaviour","title":"Define Run Behaviour","text":"<p>Our <code>app_run()</code> function is very similar to the previous example. If a flag is set, we toggle an LED and clear the flag. The flag will be set  in our button callback below. In this example, we toggle the <code>[Play]</code> button LED.</p> <pre><code>void app_run(void) {\n\n    if (g_toggle_led) {\n        ft_toggle_led(LED_PLAY);\n\n        g_toggle_led = false;\n    }\n}\n</code></pre>"},{"location":"user-input/#define-knob-callback","title":"Define Knob Callback","text":"<p>The knob callback takes 2 arguments and returns nothing.  The first argument is the index of the knob and the second is it's value.  In this example, we send a MIDI CC message on channel 1, with CC number equal to knob index and CC value equal to half knob value. The panel MCU sends 8 bit unsigned values in the range 0...255 for knobs, so we right shift  by 1 for MIDI CC values.  We could save the knob index and value to a static global variable and send MIDI messages in the <code>app_run()</code> function, but as the <code>ft_send_cc()</code> function is  non-blocking there is little advantage in this small application.</p> <pre><code>void _knob_callback(uint8_t index, uint8_t value) {\n\n    ft_send_cc(0, index, value &gt;&gt; 1);\n}\n</code></pre>"},{"location":"user-input/#define-button-callback","title":"Define Button Callback","text":"<pre><code>void _button_callback(uint8_t index, bool state) {\n\n    switch (index) {\n\n    case BUTTON_PLAY:\n    if (state == 1) {\n        g_toggle_led == true;\n    }\n        break;\n    }\n}\n</code></pre>"},{"location":"user-input/#build-and-run-the-application","title":"Build and Run the Application","text":"<p>Build the application by passing <code>midi-knob</code> to <code>make</code> in the <code>APP</code> environment variable:</p> <pre><code>make clean &amp;&amp; make APP=midi-knob\n</code></pre> <p>Then run the application using GDB:</p> <pre><code>cd cpu &amp;&amp; arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>cpu/.gdbinit</code> should take care of attaching to the debugger's GDB server and loading the ELF.</p> <p>If all is well, moving any of the knobs should send MIDI CC messages. Pressing the <code>[Play]</code> button should toggle it's LED.</p>"},{"location":"user-input/#midi-knobc","title":"<code>midi-knob.c</code>","text":"<pre><code>// Freetribe: midi-knob \n// License: AGPL-3.0-or-later\n\n/*----- Includes -----------------------------------------------------*/\n\n#include \"freetribe.h\"\n\n/*----- Macros and Definitions ---------------------------------------*/\n\n#define BUTTON_PLAY 0xa\n\n/*----- Static variable definitions ----------------------------------*/\n\nstatic bool g_toggle_led = false;\n\n/*----- Extern variable definitions ----------------------------------*/\n\n/*----- Static function prototypes -----------------------------------*/\n\nvoid _knob_callback(uint8_t index, uint8_t value); \nvoid _button_callback(uint8_t index, bool state); \n\n/*----- Extern function implementations ------------------------------*/\n\n/**\n * @brief   Initialise application. \n */\nt_status app_init(void) {\n\n    t_status status = ERROR;\n\n    ft_register_panel_callback(KNOB_EVENT, _knob_callback);\n    ft_register_panel_callback(BUTTON_EVENT, _button_callback);\n\n    status = SUCCESS;\n\n    return status;\n}\n\n/**\n * @brief   Run application.\n */\nvoid app_run(void) {\n\n    if (g_toggle_led) {\n        ft_toggle_led(LED_PLAY);\n\n        g_toggle_led = false;\n    }\n}\n\n/*----- Static function implementations ------------------------------*/\n\n/**\n * @brief   Callback triggered by panel knob events.\n */\nvoid _knob_callback(uint8_t index, uint8_t value) {\n\n    ft_send_cc(0, index, value &gt;&gt; 1);\n}\n\n/**\n * @brief   Callback triggered by panel button events.\n */\nvoid _button_callback(uint8_t index, bool state) {\n\n    switch (index) {\n\n    case BUTTON_PLAY:\n    if (state == 1) {\n        g_toggle_led == true;\n    }\n        break;\n    }\n}\n\n/*----- End of file --------------------------------------------------*/\n</code></pre>"}]}